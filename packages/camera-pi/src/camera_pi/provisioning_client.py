# SPDX-License-Identifier: Apache-2.0
# Copyright (C) 2024-2026 The Birthmark Standard Foundation

"""
Provisioning client for loading device provisioning data.

Loads provisioning data from SMA (Simulated Manufacturer Authority).
In Phase 1, data is loaded from a JSON file generated by SMA provisioning script.
"""

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


@dataclass
class ProvisioningData:
    """
    Complete device provisioning data from SMA.

    This data is generated by the SMA during device provisioning and
    contains everything needed for the camera to authenticate images.
    """
    device_serial: str
    device_certificate: str      # PEM-encoded X.509 certificate
    certificate_chain: str       # PEM-encoded intermediate CA cert
    device_private_key: str      # PEM-encoded ECDSA P-256 private key
    device_public_key: str       # PEM-encoded ECDSA P-256 public key
    table_assignments: list[int] # 3 table IDs assigned to this device
    nuc_hash: str               # Hex-encoded 32-byte NUC hash
    device_family: str           # "Raspberry Pi", "iOS", etc.
    master_keys: dict[int, str]  # table_id -> hex master_key (Phase 1 only)

    def get_master_key_bytes(self, table_id: int) -> bytes:
        """
        Get master key for a specific table as bytes.

        Args:
            table_id: Table ID from table_assignments

        Returns:
            32-byte master key

        Raises:
            KeyError: If table_id not in master_keys
        """
        if table_id not in self.master_keys:
            raise KeyError(f"No master key for table {table_id}")
        return bytes.fromhex(self.master_keys[table_id])

    def get_all_master_keys_bytes(self) -> dict[int, bytes]:
        """
        Get all master keys as bytes dictionary.

        Returns:
            Dictionary mapping table_id -> 32-byte master key
        """
        return {
            table_id: bytes.fromhex(key_hex)
            for table_id, key_hex in self.master_keys.items()
        }

    def get_nuc_hash_bytes(self) -> bytes:
        """
        Get NUC hash as bytes.

        Returns:
            32-byte NUC hash
        """
        return bytes.fromhex(self.nuc_hash)

    @classmethod
    def from_dict(cls, data: dict) -> 'ProvisioningData':
        """
        Create ProvisioningData from dictionary.

        Args:
            data: Dictionary from JSON file

        Returns:
            ProvisioningData instance
        """
        # Convert master_keys dict keys to integers
        master_keys = {
            int(table_id): key_hex
            for table_id, key_hex in data['master_keys'].items()
        }

        return cls(
            device_serial=data['device_serial'],
            device_certificate=data['device_certificate'],
            certificate_chain=data['certificate_chain'],
            device_private_key=data['device_private_key'],
            device_public_key=data['device_public_key'],
            table_assignments=data['table_assignments'],
            nuc_hash=data['nuc_hash'],
            device_family=data['device_family'],
            master_keys=master_keys
        )

    def to_dict(self) -> dict:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary representation
        """
        return {
            'device_serial': self.device_serial,
            'device_certificate': self.device_certificate,
            'certificate_chain': self.certificate_chain,
            'device_private_key': self.device_private_key,
            'device_public_key': self.device_public_key,
            'table_assignments': self.table_assignments,
            'nuc_hash': self.nuc_hash,
            'device_family': self.device_family,
            'master_keys': self.master_keys
        }


class ProvisioningClient:
    """
    Client for loading and managing provisioning data.

    In Phase 1, loads from local JSON file.
    In Phase 2+, would fetch from SMA API during provisioning.
    """

    def __init__(self, provisioning_path: Optional[Path] = None):
        """
        Initialize provisioning client.

        Args:
            provisioning_path: Path to provisioning JSON file
                              (default: ./data/provisioning.json)
        """
        if provisioning_path is None:
            provisioning_path = Path(__file__).parent.parent.parent / "data" / "provisioning.json"

        self.provisioning_path = Path(provisioning_path)
        self._data: Optional[ProvisioningData] = None

    def load_from_file(self, path: Optional[Path] = None) -> ProvisioningData:
        """
        Load provisioning data from JSON file.

        Args:
            path: Optional path to JSON file (uses default if None)

        Returns:
            ProvisioningData instance

        Raises:
            FileNotFoundError: If provisioning file doesn't exist
            ValueError: If provisioning data is invalid
        """
        if path is None:
            path = self.provisioning_path

        if not path.exists():
            raise FileNotFoundError(
                f"Provisioning file not found: {path}\n"
                "Run provisioning script first: scripts/provision_device.py"
            )

        with open(path, 'r') as f:
            data_dict = json.load(f)

        # Validate required fields
        required_fields = [
            'device_serial',
            'device_certificate',
            'certificate_chain',
            'device_private_key',
            'device_public_key',
            'table_assignments',
            'nuc_hash',
            'device_family',
            'master_keys'
        ]

        missing_fields = [f for f in required_fields if f not in data_dict]
        if missing_fields:
            raise ValueError(f"Missing required fields: {missing_fields}")

        # Validate table assignments
        if len(data_dict['table_assignments']) != 3:
            raise ValueError(
                f"Expected 3 table assignments, got {len(data_dict['table_assignments'])}"
            )

        # Validate master keys match table assignments
        master_keys = data_dict['master_keys']
        for table_id in data_dict['table_assignments']:
            if str(table_id) not in master_keys:
                raise ValueError(f"Missing master key for table {table_id}")

        # Parse and cache
        self._data = ProvisioningData.from_dict(data_dict)
        return self._data

    def save_to_file(self, data: ProvisioningData, path: Optional[Path] = None) -> None:
        """
        Save provisioning data to JSON file.

        Args:
            data: ProvisioningData to save
            path: Optional path to JSON file (uses default if None)
        """
        if path is None:
            path = self.provisioning_path

        # Ensure directory exists
        path.parent.mkdir(parents=True, exist_ok=True)

        with open(path, 'w') as f:
            json.dump(data.to_dict(), f, indent=2)

    def get_data(self) -> ProvisioningData:
        """
        Get cached provisioning data.

        Returns:
            Cached ProvisioningData

        Raises:
            RuntimeError: If data not loaded yet
        """
        if self._data is None:
            raise RuntimeError("Provisioning data not loaded. Call load_from_file() first.")
        return self._data

    def is_loaded(self) -> bool:
        """
        Check if provisioning data is loaded.

        Returns:
            True if data is loaded, False otherwise
        """
        return self._data is not None

    def get_device_info(self) -> dict:
        """
        Get non-sensitive device information.

        Returns:
            Dictionary with device serial, family, and table assignments
        """
        data = self.get_data()
        return {
            'device_serial': data.device_serial,
            'device_family': data.device_family,
            'table_assignments': data.table_assignments,
            'nuc_hash_preview': data.nuc_hash[:16] + '...',  # First 16 chars only
        }


def create_example_provisioning_file(output_path: Path) -> None:
    """
    Create an example provisioning file for testing.

    This is NOT a real provisioning - use SMA provisioning script instead.

    Args:
        output_path: Path to save example file
    """
    import secrets

    example_data = {
        "device_serial": "EXAMPLE-DEVICE-001",
        "device_certificate": "-----BEGIN CERTIFICATE-----\nEXAMPLE\n-----END CERTIFICATE-----",
        "certificate_chain": "-----BEGIN CERTIFICATE-----\nEXAMPLE\n-----END CERTIFICATE-----",
        "device_private_key": "-----BEGIN PRIVATE KEY-----\nEXAMPLE\n-----END PRIVATE KEY-----",
        "device_public_key": "-----BEGIN PUBLIC KEY-----\nEXAMPLE\n-----END PUBLIC KEY-----",
        "table_assignments": [3, 7, 9],
        "nuc_hash": secrets.token_bytes(32).hex(),
        "device_family": "Raspberry Pi",
        "master_keys": {
            "3": secrets.token_bytes(32).hex(),
            "7": secrets.token_bytes(32).hex(),
            "9": secrets.token_bytes(32).hex()
        }
    }

    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w') as f:
        json.dump(example_data, f, indent=2)

    print(f"Example provisioning file created: {output_path}")
    print("WARNING: This is NOT real provisioning data!")
    print("Use SMA provisioning script for actual device provisioning.")


if __name__ == "__main__":
    # Example usage
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == "create-example":
        # Create example file
        example_path = Path("./data/example_provisioning.json")
        create_example_provisioning_file(example_path)
    else:
        # Try to load provisioning data
        client = ProvisioningClient()
        try:
            data = client.load_from_file()
            print("✓ Provisioning data loaded successfully")
            print(f"  Device: {data.device_serial}")
            print(f"  Family: {data.device_family}")
            print(f"  Tables: {data.table_assignments}")
            print(f"  NUC hash: {data.nuc_hash[:16]}...")
        except FileNotFoundError as e:
            print(f"✗ {e}")
            print("\nTo create example file:")
            print("  python -m camera_pi.provisioning_client create-example")
